// Generated by CoffeeScript 1.10.0
(function() {
  var Connection, MSSQLConnection, Request, genericPool, url,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Connection = require('tedious').Connection;

  Request = require('tedious').Request;

  genericPool = require('generic-pool');

  url = require('url');

  MSSQLConnection = (function(superClass) {
    extend(MSSQLConnection, superClass);

    function MSSQLConnection(name, options1) {
      this.name = name;
      this.options = options1;
      MSSQLConnection.__super__.constructor.apply(this, arguments);
      this.pool = genericPool.Pool({
        name: this.name,
        max: 1,
        create: (function(_this) {
          return function(callback) {
            var cnfg, connected, connection;
            cnfg = _this._parseOptions(_this.options);
            cnfg.options = cnfg.options || {};
            cnfg.options.requestTimeout = cnfg.options.requestTimeout || 60 * 5 * 1000;
            connection = new Connection(cnfg);
            connected = false;
            return connection.on('connect', function(err) {
              if (connected) {
                return;
              }
              connected = true;
              return callback(err, connection);
            });
          };
        })(this),
        destroy: (function(_this) {
          return function(connection) {
            return connection.close();
          };
        })(this)
      });
    }

    MSSQLConnection.prototype.query = function(sql, rowCallback, callback, batchSize) {
      return this.pool.acquire((function(_this) {
        return function(err, connection) {
          var columns, data, request, rows;
          data = [];
          columns = [];
          rows = 0;
          request = new Request(sql, function(err, rowCount) {
            callback(err, data, columns, true);
            return _this.pool.release(connection);
          });
          request.on('err', function(err) {
            callback(err);
            return _this.pool.release(connection);
          }).on('columnMetadata', function(metadata) {
            var j, len, meta;
            for (j = 0, len = metadata.length; j < len; j++) {
              meta = metadata[j];
              columns.push(meta.colName);
            }
            return columns = columns.filter(function(e, i, arr) {
              return arr.lastIndexOf(e) === i;
            });
          }).on('row', function(row) {
            var __row, _row, col, column, j, k, len, len1;
            _row = [];
            __row = {};
            for (j = 0, len = row.length; j < len; j++) {
              col = row[j];
              __row[col.metadata.colName] = col.value;
            }
            if (rowCallback) {
              rowCallback(__row);
            }
            for (k = 0, len1 = columns.length; k < len1; k++) {
              column = columns[k];
              _row.push(__row[column]);
            }
            data.push(_row);
            if (batchSize && data.length >= batchSize) {
              callback(null, data, columns, false);
              data = [];
            }
            return rows++;
          }).on('done', function(rowCount, more) {});
          return connection.execSqlBatch(request);
        };
      })(this));
    };

    MSSQLConnection.prototype.createSQL = function(columns, rows, table) {
      var _rows, columnAssigns, i, ii, keys, ref, sql;
      keys = [];
      _rows = [];
      for (i in columns) {
        keys.push(columns[i] + " = VALUES(" + columns[i] + ")");
      }
      for (i in rows) {
        _rows[i] = _rows[i] || [];
        for (ii in rows[i]) {
          _rows[i][ii] = mysql.escape(rows[i][ii]);
          if ((ref = _rows[i][ii]) != null ? ref.replace : void 0) {
            _rows[i][ii] = _rows[i][ii].replace(/\\'/g, "''");
          }
          if (_rows[i][ii] === null) {
            _rows[i][ii] = "null";
          }
        }
        _rows[i] = _rows[i].join(",");
      }
      sql = "MERGE `" + table + "` USING (VALUES(" + _rows.join("),(") + ")) AS foo(" + columns.join(",") + ") ON `" + table + "`.id = foo.id";
      columnAssigns = [];
      for (i in columns) {
        columnAssigns.push(columns[i] + "=foo." + columns[i]);
      }
      sql += " WHEN MATCHED THEN UPDATE SET " + columnAssigns.join(",");
      sql += " WHEN NOT MATCHED THEN INSERT (" + columns.join(",") + ") VALUES(" + columns.join(",") + ");";
      return sql;
    };

    MSSQLConnection.prototype.close = function() {
      return this.pool.drain((function(_this) {
        return function() {
          _this.pool.destroyAllNow();
        };
      })(this));
    };

    MSSQLConnection.prototype._parseOptions = function(options) {
      var parsedUrl, splittedAuth;
      if (typeof options !== 'string') {
        return options;
      }
      parsedUrl = url.parse(options);
      splittedAuth = parsedUrl.auth.split(':');
      return {
        userName: splittedAuth[0],
        password: splittedAuth[1],
        server: parsedUrl.host,
        database: parsedUrl.pathname
      };
    };

    return MSSQLConnection;

  })(Object);

  module.exports = MSSQLConnection;

}).call(this);
